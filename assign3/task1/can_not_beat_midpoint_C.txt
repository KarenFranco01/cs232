To fail midpoint_A and midpoint_B, I used 1 and 0. For both examples, I looked at both 1 and 0 and -1 and 0. For 1 and 0, the midpoints for A and B do not match up. Instead of rounding down like micdpoint C does, it kept the original value. Midpoint A tends to use the first input to select its midpoint, which C seems to be the true value. The midpoint for 1 and 0 is .5, so with rounding it should equal 0, so C is correct. Using -1 and 0, the midpoint would be -.5. This would mean that the midpoint should round to -1, which is done by C correctly. Since the midpoint is a negative number, midpoint B fails. Midpoint A again returns the first integer input, which is -1.